```c
题目描述:
----------------
对一个单向无序链表进行升序排序，要求空间复杂度为O(1)
```
采用冒泡排序比较直接，先将最大数沉到最后，也就是第一次内循环是循环到n，然后次大数沉到倒数第二，也就是内循环到n-1，如此类推。
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *cur, *prev, *p_end, *prev_head;
        prev_head = new ListNode(10);
        prev_head->next = head;
        cur = head;
        p_end = NULL;
        //由于head自己也可能被交换到其他位置，因此起始位置的node并非一直是head
        //定义附加的一个node来指向链表初始node，因此链表初始位置一直是prev_head->next，同时方便后面的node交换
        while(p_end != prev_head->next) {
            cur = prev_head->next;
            prev = prev_head;
            while (cur->next != p_end) {
                if(cur->val > cur->next->val) {
                    //链表交换node,交换node的prev和next必需要单独保存
                    ListNode *temp = cur->next->next;
                    prev->next = cur->next;
                    cur->next->next = cur;
                    cur->next = temp;
                    //因为cur和cur->next交换位置，因此要将cur重新指向当前位置的node
                    cur = prev->next; 
                }
                cur = cur->next;
                prev = prev->next;
                //p_end = cur;
            }
            p_end = cur;//下一次循环比这次往前一个node
        }
        head = prev_head->next;
        delete prev_head;
        return head;
    }
};
```

```c
    void swap(ListNode* prev_a, ListNode* a, ListNode* prev_b, ListNode* b) {
        ListNode *temp_a_next, *temp_b_next;
        temp_a_next = a->next;
        temp_b_next = b->next;
        if (a != b) {
            if (prev_b != a && prev_a != b) {
                prev_a->next = b;
                b->next = temp_a_next;
                prev_b->next = a;
                a->next = temp_b_next;
            }
            else if (prev_b == a){
                prev_a->next = b;
                b->next = a;
                a->next = temp_b_next;
                prev_b = b;
            }
            else if (prev_a == b) {
                prev_b->next = a;
                a->next = b;
                b->next = temp_a_next;
                prev_a = a;
            }
        }
        
    }
    
    ListNode* qsortdivide(ListNode *prev_start, ListNode *start, ListNode *end) {
        if (start == end || start == NULL || end == NULL) return NULL;
        ListNode *key = start;
        ListNode *cur = start, *prev_cur = prev_start, *prev_key = prev_start;
        ListNode *end_next = end->next;
        while(cur != end_next) {
            if (key->val > cur->val) {
                swap(prev_cur, cur, prev_key, key);
                //ListNode* temp = prev_key;
                prev_key = prev_cur;
                //prev_cur = temp;
            }
            cur = prev_cur->next->next;
            prev_cur = prev_cur->next;
        }
        return prev_key;
    }
    
    
    void qsort(ListNode *prev_start, ListNode *start, ListNode *end) {
        ListNode *key = qsortdivide( prev_start,  start,  end);
        if(key == NULL) return;
        qsort(prev_start, start, key);
        qsort(key->next, key->next->next, end);
    }
    
    
    
    ListNode* sortList(ListNode* head) {
        ListNode *prev_head = new ListNode(10);
        prev_head->next = head;
        ListNode *end = head;
        while(end->next != NULL) {
            end = end->next;
        }
        qsort(prev_head, head, end);
        head = prev_head->next;
        delete prev_head;
        return head;
    }
```


